---
alwaysApply: true
---

# Data Patterns & Validation

## Overview
This project follows strict patterns for data handling:
- **Data Layer**: ALL database operations MUST be in `db/queries` directory as helper functions
- **Data Retrieval**: Always use Server Components that call query helpers
- **Data Mutations**: Always use Server Actions that call mutation helpers
- **Data Validation**: Always use Zod schemas
- **Type Safety**: All server actions must use typed parameters (NO FormData types)
- **NO Direct DB Access**: NEVER call `db.select()`, `db.insert()`, `db.update()`, or `db.delete()` outside of `db/queries` directory

## 1. Database Queries Directory Structure

ALL database operations MUST be organized in the `db/queries` directory. Each file contains query and mutation helpers for a specific domain.

### Directory Structure

```
db/
‚îú‚îÄ‚îÄ index.ts          # Database client
‚îú‚îÄ‚îÄ schema.ts         # Database schema
‚îî‚îÄ‚îÄ queries/
    ‚îú‚îÄ‚îÄ decks.ts      # Deck-related queries and mutations
    ‚îú‚îÄ‚îÄ cards.ts      # Card-related queries and mutations
    ‚îî‚îÄ‚îÄ ...           # Other domain-specific query files
```

### Query Helper Pattern

```typescript
// db/queries/decks.ts
import { db } from '@/db';
import { decksTable } from '@/db/schema';
import { eq, and } from 'drizzle-orm';

// ============= QUERIES (Read Operations) =============

export async function getDecksByUserId(userId: string) {
  return await db
    .select()
    .from(decksTable)
    .where(eq(decksTable.userId, userId));
}

export async function getDeckById(deckId: number, userId: string) {
  const [deck] = await db
    .select()
    .from(decksTable)
    .where(and(
      eq(decksTable.id, deckId),
      eq(decksTable.userId, userId)
    ))
    .limit(1);
  
  return deck;
}

// ============= MUTATIONS (Write Operations) =============

export async function insertDeck(userId: string, name: string, description: string) {
  const [newDeck] = await db
    .insert(decksTable)
    .values({
      userId,
      name,
      description,
    })
    .returning();
  
  return newDeck;
}

export async function updateDeckById(
  deckId: number,
  userId: string,
  updates: { name?: string; description?: string }
) {
  const [updatedDeck] = await db
    .update(decksTable)
    .set({
      ...updates,
      updatedAt: new Date(),
    })
    .where(and(
      eq(decksTable.id, deckId),
      eq(decksTable.userId, userId)
    ))
    .returning();
  
  return updatedDeck;
}

export async function deleteDeckById(deckId: number, userId: string) {
  const [deletedDeck] = await db
    .delete(decksTable)
    .where(and(
      eq(decksTable.id, deckId),
      eq(decksTable.userId, userId)
    ))
    .returning();
  
  return deletedDeck;
}
```

### Key Rules for Query Files

1. **All Drizzle operations in queries directory** - NEVER use `db.select()`, `db.insert()`, etc. outside of `db/queries`
2. **One file per domain** - Keep related queries together (e.g., all deck operations in `decks.ts`)
3. **Export named functions** - Each query should be a named export with a clear purpose
4. **Include userId in mutations** - Always require userId parameter for ownership verification
5. **Return data directly** - Don't wrap in response objects, just return the data
6. **Handle auth in caller** - Query helpers don't authenticate, they assume valid userId

## 2. Data Retrieval - Server Components Only

All data fetching MUST be done in Server Components using query helpers. Never fetch data in Client Components.

### ‚úÖ CORRECT - Server Component Using Query Helpers

```typescript
// app/dashboard/page.tsx (Server Component by default)
import { auth } from '@clerk/nextjs/server';
import { redirect } from 'next/navigation';
import { getDecksByUserId } from '@/db/queries/decks';

export default async function DashboardPage() {
  const { userId } = await auth();
  
  if (!userId) {
    redirect('/');
  }

  // Use query helper to fetch data
  const decks = await getDecksByUserId(userId);

  return (
    <div>
      {decks.map(deck => (
        <DeckCard key={deck.id} deck={deck} />
      ))}
    </div>
  );
}
```

### ‚ùå WRONG - Direct Database Access in Server Component

```typescript
// app/dashboard/page.tsx
import { auth } from '@clerk/nextjs/server';
import { db } from '@/db';
import { decksTable } from '@/db/schema';
import { eq } from 'drizzle-orm';

export default async function DashboardPage() {
  const { userId } = await auth();
  
  if (!userId) {
    redirect('/');
  }

  // WRONG - Never use direct db calls outside of db/queries directory
  const decks = await db
    .select()
    .from(decksTable)
    .where(eq(decksTable.userId, userId));

  return <div>{/* ... */}</div>;
}
```

### ‚ùå WRONG - Client Component Data Fetching

```typescript
'use client';

import { useEffect, useState } from 'react';

// WRONG - Never fetch data in client components
export default function DashboardPage() {
  const [decks, setDecks] = useState([]);

  useEffect(() => {
    fetch('/api/decks')
      .then(res => res.json())
      .then(data => setDecks(data.decks));
  }, []);

  return <div>{/* ... */}</div>;
}
```

### Pattern: Server Component ‚Üí Client Component

When you need interactivity, fetch in Server Component using query helpers and pass to Client Component:

```typescript
// app/dashboard/page.tsx (Server Component)
import { auth } from '@clerk/nextjs/server';
import { redirect } from 'next/navigation';
import { getDecksByUserId } from '@/db/queries/decks';
import { DecksList } from '@/components/DecksList';

export default async function DashboardPage() {
  const { userId } = await auth();
  
  if (!userId) {
    redirect('/');
  }

  // Use query helper to fetch data
  const decks = await getDecksByUserId(userId);

  // Pass data as props to client component
  return <DecksList decks={decks} />;
}
```

```typescript
// components/DecksList.tsx (Client Component)
'use client';

import type { InferSelectModel } from 'drizzle-orm';
import { decksTable } from '@/db/schema';

type Deck = InferSelectModel<typeof decksTable>;

export function DecksList({ decks }: { decks: Deck[] }) {
  // Now you can use client-side features like state, events, etc.
  return (
    <div>
      {decks.map(deck => (
        <div key={deck.id} onClick={() => console.log(deck.id)}>
          {deck.name}
        </div>
      ))}
    </div>
  );
}
```

## 3. Data Mutations - Server Actions Only

All database inserts, updates, and deletes MUST be done through Server Actions that call mutation helpers from `db/queries`. Never use API routes for mutations.

### ‚úÖ CORRECT - Server Action Using Mutation Helpers

```typescript
// app/actions/deck-actions.ts
'use server';

import { auth } from '@clerk/nextjs/server';
import { revalidatePath } from 'next/cache';
import { z } from 'zod';
import { 
  insertDeck, 
  updateDeckById, 
  deleteDeckById 
} from '@/db/queries/decks';

// Define Zod schema for validation
const CreateDeckSchema = z.object({
  name: z.string().min(1, 'Name is required').max(100, 'Name too long'),
  description: z.string().max(500, 'Description too long').optional(),
});

// Define TypeScript type from Zod schema
type CreateDeckInput = z.infer<typeof CreateDeckSchema>;

export async function createDeck(input: CreateDeckInput) {
  const { userId } = await auth();
  
  if (!userId) {
    throw new Error('Unauthorized');
  }

  // Validate input with Zod
  const validatedData = CreateDeckSchema.parse(input);

  // Call mutation helper from db/queries
  const newDeck = await insertDeck(
    userId,
    validatedData.name,
    validatedData.description || ''
  );

  // Revalidate the page to show new data
  revalidatePath('/dashboard');

  return newDeck;
}

// Update action
const UpdateDeckSchema = z.object({
  id: z.number(),
  name: z.string().min(1).max(100).optional(),
  description: z.string().max(500).optional(),
});

type UpdateDeckInput = z.infer<typeof UpdateDeckSchema>;

export async function updateDeck(input: UpdateDeckInput) {
  const { userId } = await auth();
  
  if (!userId) {
    throw new Error('Unauthorized');
  }

  const validatedData = UpdateDeckSchema.parse(input);

  // Call mutation helper from db/queries
  const updatedDeck = await updateDeckById(
    validatedData.id,
    userId,
    {
      name: validatedData.name,
      description: validatedData.description,
    }
  );

  if (!updatedDeck) {
    throw new Error('Deck not found');
  }

  revalidatePath('/dashboard');

  return updatedDeck;
}

// Delete action
const DeleteDeckSchema = z.object({
  id: z.number(),
});

type DeleteDeckInput = z.infer<typeof DeleteDeckSchema>;

export async function deleteDeck(input: DeleteDeckInput) {
  const { userId } = await auth();
  
  if (!userId) {
    throw new Error('Unauthorized');
  }

  const validatedData = DeleteDeckSchema.parse(input);

  // Call mutation helper from db/queries
  const deletedDeck = await deleteDeckById(validatedData.id, userId);

  if (!deletedDeck) {
    throw new Error('Deck not found');
  }

  revalidatePath('/dashboard');

  return { success: true };
}
```

### ‚ùå WRONG - Direct Database Access in Server Action

```typescript
// app/actions/deck-actions.ts
'use server';

import { db } from '@/db';
import { decksTable } from '@/db/schema';
import { z } from 'zod';

const CreateDeckSchema = z.object({
  name: z.string().min(1).max(100),
  description: z.string().max(500).optional(),
});

type CreateDeckInput = z.infer<typeof CreateDeckSchema>;

export async function createDeck(input: CreateDeckInput) {
  const { userId } = await auth();
  
  if (!userId) {
    throw new Error('Unauthorized');
  }

  const validatedData = CreateDeckSchema.parse(input);

  // WRONG - Never use direct db calls outside of db/queries directory
  const [newDeck] = await db
    .insert(decksTable)
    .values({
      userId,
      name: validatedData.name,
      description: validatedData.description || '',
    })
    .returning();

  revalidatePath('/dashboard');

  return newDeck;
}
```

### ‚ùå WRONG - Using API Routes for Mutations

```typescript
// app/api/decks/route.ts
// WRONG - Never use API routes for mutations
export async function POST(request: Request) {
  const body = await request.json();
  // This is wrong - use server actions instead
}
```

### ‚ùå WRONG - Using FormData Type

```typescript
'use server';

// NEVER use FormData as the parameter type
export async function createDeck(formData: FormData) {
  const name = formData.get('name') as string;
  // This is wrong - use typed parameters with Zod validation
}
```

### Using Server Actions in Client Components

```typescript
// components/CreateDeckForm.tsx
'use client';

import { useState } from 'react';
import { createDeck } from '@/app/actions/deck-actions';
import { Button } from '@/components/ui/button';
import { Input } from '@/components/ui/input';
import { Label } from '@/components/ui/label';
import { Textarea } from '@/components/ui/textarea';

export function CreateDeckForm() {
  const [name, setName] = useState('');
  const [description, setDescription] = useState('');

  async function handleSubmit(e: React.FormEvent) {
    e.preventDefault();

    try {
      // Call server action with typed object
      await createDeck({
        name,
        description,
      });
      
      // Reset form
      setName('');
      setDescription('');
    } catch (error) {
      console.error('Failed to create deck:', error);
    }
  }

  return (
    <form onSubmit={handleSubmit}>
      <div>
        <Label htmlFor="name">Name</Label>
        <Input
          id="name"
          value={name}
          onChange={(e) => setName(e.target.value)}
        />
      </div>
      <div>
        <Label htmlFor="description">Description</Label>
        <Textarea
          id="description"
          value={description}
          onChange={(e) => setDescription(e.target.value)}
        />
      </div>
      <Button type="submit">Create Deck</Button>
    </form>
  );
}
```

## 4. Data Validation - Always Use Zod

ALL data passed to server actions MUST be validated using Zod schemas.

### Zod Schema Patterns

```typescript
import { z } from 'zod';

// Basic schema
const DeckSchema = z.object({
  name: z.string().min(1, 'Name is required').max(100),
  description: z.string().max(500).optional(),
});

// Schema with transformations
const CardSchema = z.object({
  front: z.string().min(1, 'Question is required').trim(),
  back: z.string().min(1, 'Answer is required').trim(),
  deckId: z.number().positive(),
});

// Schema with refinements
const UpdateCardSchema = z.object({
  id: z.number(),
  front: z.string().min(1).max(1000),
  back: z.string().min(1).max(1000),
}).refine(data => data.front !== data.back, {
  message: "Question and answer cannot be the same",
});

// Nested schemas
const DeckWithCardsSchema = z.object({
  name: z.string().min(1).max(100),
  description: z.string().max(500).optional(),
  cards: z.array(z.object({
    front: z.string().min(1),
    back: z.string().min(1),
  })).min(1, 'At least one card is required'),
});
```

### Server Action Validation Pattern

```typescript
'use server';

import { z } from 'zod';
import { auth } from '@clerk/nextjs/server';
import { db } from '@/db';

// 1. Define Zod schema
const Schema = z.object({
  // ... schema definition
});

// 2. Infer TypeScript type from schema
type Input = z.infer<typeof Schema>;

// 3. Use typed parameter in server action
export async function serverAction(input: Input) {
  const { userId } = await auth();
  
  if (!userId) {
    throw new Error('Unauthorized');
  }

  // 4. Validate with Zod
  const validatedData = Schema.parse(input);

  // 5. Use validated data
  const result = await db.insert(table).values({
    userId,
    ...validatedData,
  });

  return result;
}
```

### Error Handling with Zod

```typescript
'use server';

import { z } from 'zod';

const Schema = z.object({
  name: z.string().min(1, 'Name is required'),
});

type Input = z.infer<typeof Schema>;

export async function serverAction(input: Input) {
  try {
    const validatedData = Schema.parse(input);
    // ... rest of action
  } catch (error) {
    if (error instanceof z.ZodError) {
      // Return validation errors to client
      return {
        success: false,
        errors: error.errors.map(e => ({
          field: e.path.join('.'),
          message: e.message,
        })),
      };
    }
    throw error;
  }
}
```

## 5. Type Safety Requirements

### ‚úÖ CORRECT - Typed Parameters

```typescript
'use server';

import { z } from 'zod';

const CreateDeckSchema = z.object({
  name: z.string(),
  description: z.string().optional(),
});

type CreateDeckInput = z.infer<typeof CreateDeckSchema>;

export async function createDeck(input: CreateDeckInput) {
  const validatedData = CreateDeckSchema.parse(input);
  // ...
}
```

### ‚ùå WRONG - FormData Type

```typescript
'use server';

// NEVER use FormData as parameter type
export async function createDeck(formData: FormData) {
  // This is wrong
}
```

### ‚ùå WRONG - Unvalidated Any Type

```typescript
'use server';

// NEVER use any or unvalidated data
export async function createDeck(data: any) {
  // This is wrong - no type safety or validation
}
```

## Complete Example

### Query Helper File

```typescript
// db/queries/decks.ts
import { db } from '@/db';
import { decksTable } from '@/db/schema';
import { eq, and } from 'drizzle-orm';

export async function getDecksByUserId(userId: string) {
  return await db
    .select()
    .from(decksTable)
    .where(eq(decksTable.userId, userId));
}

export async function insertDeck(userId: string, name: string, description: string) {
  const [newDeck] = await db
    .insert(decksTable)
    .values({
      userId,
      name,
      description,
    })
    .returning();
  
  return newDeck;
}
```

### Server Action

```typescript
// app/actions/deck-actions.ts
'use server';

import { auth } from '@clerk/nextjs/server';
import { revalidatePath } from 'next/cache';
import { z } from 'zod';
import { insertDeck } from '@/db/queries/decks';

// Schema
const CreateDeckSchema = z.object({
  name: z.string().min(1, 'Name is required').max(100),
  description: z.string().max(500).optional(),
});

// Type
type CreateDeckInput = z.infer<typeof CreateDeckSchema>;

// Server Action
export async function createDeck(input: CreateDeckInput) {
  const { userId } = await auth();
  
  if (!userId) {
    throw new Error('Unauthorized');
  }

  // Validate
  const validatedData = CreateDeckSchema.parse(input);

  // Call mutation helper
  const newDeck = await insertDeck(
    userId,
    validatedData.name,
    validatedData.description || ''
  );

  // Revalidate
  revalidatePath('/dashboard');

  return newDeck;
}
```

### Server Component

```typescript
// app/dashboard/page.tsx (Server Component)
import { auth } from '@clerk/nextjs/server';
import { redirect } from 'next/navigation';
import { getDecksByUserId } from '@/db/queries/decks';
import { DecksList } from '@/components/DecksList';

export default async function DashboardPage() {
  const { userId } = await auth();
  
  if (!userId) {
    redirect('/');
  }

  // Call query helper
  const decks = await getDecksByUserId(userId);

  return <DecksList decks={decks} />;
}
```

```typescript
// components/DecksList.tsx (Client Component)
'use client';

import type { InferSelectModel } from 'drizzle-orm';
import { decksTable } from '@/db/schema';
import { createDeck, deleteDeck } from '@/app/actions/deck-actions';

type Deck = InferSelectModel<typeof decksTable>;

export function DecksList({ decks }: { decks: Deck[] }) {
  async function handleCreate() {
    // Call server action with typed object
    await createDeck({
      name: 'New Deck',
      description: 'Description',
    });
  }

  async function handleDelete(id: number) {
    // Call server action with typed object
    await deleteDeck({ id });
  }

  return <div>{/* ... */}</div>;
}
```

## Summary - Golden Rules

### üö® ALWAYS FOLLOW THESE RULES üö®

1. **Query Helpers**: ALL database operations MUST be in `db/queries` directory - NEVER use `db.select()`, `db.insert()`, `db.update()`, or `db.delete()` outside of `db/queries`
2. **Data Retrieval**: Use Server Components that call query helpers from `db/queries` - never fetch in client components
3. **Data Mutations**: Use Server Actions that call mutation helpers from `db/queries` - never use API routes for mutations
4. **Validation**: Use Zod schemas for ALL server action inputs
5. **Type Safety**: Use typed parameters (inferred from Zod) - NEVER use FormData type
6. **Revalidation**: Always call `revalidatePath()` after mutations
7. **Auth Check**: Always authenticate in server actions with `auth()` from Clerk
8. **Ownership**: Always verify user owns the resource in query helpers (require userId parameter)

### Enforcement

If you find yourself:
- Using `db.select()`, `db.insert()`, `db.update()`, or `db.delete()` outside of `db/queries` directory
- Fetching data in a Client Component with `useEffect` or `fetch`
- Creating a POST/PUT/DELETE API route
- Using `FormData` as a server action parameter type
- Not validating data with Zod
- Not having a TypeScript type for server action parameters
- Calling database operations directly instead of using query helpers

**STOP** - You are violating the data patterns. Fix it immediately.

## Resources

- [Next.js Server Components](https://nextjs.org/docs/app/building-your-application/rendering/server-components)
- [Next.js Server Actions](https://nextjs.org/docs/app/building-your-application/data-fetching/server-actions-and-mutations)
- [Zod Documentation](https://zod.dev/)
- [Drizzle ORM](https://orm.drizzle.team/)
