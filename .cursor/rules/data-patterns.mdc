---
alwaysApply: true
---

# Data Fetching & Mutation Patterns

## Overview
This project follows a strict pattern for data operations:
- **Data Retrieval** → Server Components only
- **Data Mutations** → Server Actions only
- **Validation** → Zod schemas always

## Data Retrieval

### Always Use Server Components for Fetching Data

✅ **CORRECT** - Server Component fetches data:
```tsx
import { db } from '@/db';
import { decksTable } from '@/db/schema';
import { eq } from 'drizzle-orm';
import { auth } from '@clerk/nextjs/server';

export default async function DecksPage() {
  const { userId } = await auth();
  
  if (!userId) {
    return <div>Please sign in</div>;
  }

  // Fetch data directly in server component
  const decks = await db
    .select()
    .from(decksTable)
    .where(eq(decksTable.userId, userId));

  return (
    <div>
      <h1>My Decks</h1>
      {decks.map(deck => (
        <div key={deck.id}>{deck.name}</div>
      ))}
    </div>
  );
}
```

❌ **WRONG** - Client component with useEffect:
```tsx
'use client';

import { useEffect, useState } from 'react';

export default function DecksPage() {
  const [decks, setDecks] = useState([]);

  useEffect(() => {
    // Never fetch data this way
    fetch('/api/decks')
      .then(res => res.json())
      .then(data => setDecks(data.decks));
  }, []);

  return <div>{/* ... */}</div>;
}
```

❌ **WRONG** - API Route for simple data fetching:
```tsx
// Don't create API routes just for fetching data
// app/api/decks/route.ts
export async function GET() {
  const decks = await db.select().from(decksTable);
  return Response.json({ decks });
}
```

### Pattern: Server Component with Client Children

When you need interactivity, compose server and client components:

```tsx
// app/decks/page.tsx (Server Component)
import { db } from '@/db';
import { decksTable } from '@/db/schema';
import { eq } from 'drizzle-orm';
import { auth } from '@clerk/nextjs/server';
import { DeckCard } from '@/components/deck-card'; // Client component

export default async function DecksPage() {
  const { userId } = await auth();
  
  if (!userId) {
    return <div>Please sign in</div>;
  }

  const decks = await db
    .select()
    .from(decksTable)
    .where(eq(decksTable.userId, userId));

  return (
    <div>
      <h1>My Decks</h1>
      {decks.map(deck => (
        <DeckCard key={deck.id} deck={deck} /> // Pass data as props
      ))}
    </div>
  );
}
```

```tsx
// components/deck-card.tsx (Client Component)
'use client';

import { Button } from '@/components/ui/button';
import { Card, CardContent, CardHeader, CardTitle } from '@/components/ui/card';

interface DeckCardProps {
  deck: {
    id: number;
    name: string;
    description: string | null;
  };
}

export function DeckCard({ deck }: DeckCardProps) {
  return (
    <Card>
      <CardHeader>
        <CardTitle>{deck.name}</CardTitle>
      </CardHeader>
      <CardContent>
        <p>{deck.description}</p>
        <Button onClick={() => console.log('Clicked!')}>View</Button>
      </CardContent>
    </Card>
  );
}
```

## Data Mutations

### Always Use Server Actions for Mutations

All database inserts, updates, and deletes MUST be done through Server Actions.

### Setup: Zod Schemas

Create Zod schemas for validation (typically in a separate file):

```typescript
// lib/validations.ts
import { z } from 'zod';

export const createDeckSchema = z.object({
  name: z.string().min(1, 'Name is required').max(255, 'Name is too long'),
  description: z.string().max(1000, 'Description is too long').optional(),
});

export const updateDeckSchema = z.object({
  id: z.number().positive(),
  name: z.string().min(1, 'Name is required').max(255, 'Name is too long').optional(),
  description: z.string().max(1000, 'Description is too long').optional(),
});

export const createCardSchema = z.object({
  deckId: z.number().positive(),
  front: z.string().min(1, 'Front is required').max(1000),
  back: z.string().min(1, 'Back is required').max(1000),
});

// Export types derived from schemas
export type CreateDeckInput = z.infer<typeof createDeckSchema>;
export type UpdateDeckInput = z.infer<typeof updateDeckSchema>;
export type CreateCardInput = z.infer<typeof createCardSchema>;
```

### Pattern: Server Action with Validation

✅ **CORRECT** - Server Action with Zod validation and typed input:
```typescript
'use server';

import { db } from '@/db';
import { decksTable } from '@/db/schema';
import { eq, and } from 'drizzle-orm';
import { auth } from '@clerk/nextjs/server';
import { revalidatePath } from 'next/cache';
import { createDeckSchema, type CreateDeckInput } from '@/lib/validations';

export async function createDeck(input: CreateDeckInput) {
  // 1. Authenticate
  const { userId } = await auth();
  if (!userId) {
    throw new Error('Unauthorized');
  }

  // 2. Validate with Zod
  const validatedData = createDeckSchema.parse(input);

  // 3. Database operation
  const [newDeck] = await db.insert(decksTable).values({
    userId,
    name: validatedData.name,
    description: validatedData.description || null,
  }).returning();

  // 4. Revalidate cache
  revalidatePath('/decks');

  return newDeck;
}
```

❌ **WRONG** - Using FormData as type:
```typescript
'use server';

// Never use FormData as the parameter type
export async function createDeck(formData: FormData) {
  const name = formData.get('name') as string;
  const description = formData.get('description') as string;
  // ...
}
```

❌ **WRONG** - No validation:
```typescript
'use server';

// Always validate with Zod
export async function createDeck(input: { name: string; description?: string }) {
  // Missing validation - WRONG
  const [newDeck] = await db.insert(decksTable).values({
    userId,
    name: input.name,
    description: input.description,
  }).returning();
}
```

### Pattern: Update Action

```typescript
'use server';

import { db } from '@/db';
import { decksTable } from '@/db/schema';
import { eq, and } from 'drizzle-orm';
import { auth } from '@clerk/nextjs/server';
import { revalidatePath } from 'next/cache';
import { updateDeckSchema, type UpdateDeckInput } from '@/lib/validations';

export async function updateDeck(input: UpdateDeckInput) {
  const { userId } = await auth();
  if (!userId) {
    throw new Error('Unauthorized');
  }

  const validatedData = updateDeckSchema.parse(input);

  const [updatedDeck] = await db
    .update(decksTable)
    .set({
      ...(validatedData.name && { name: validatedData.name }),
      ...(validatedData.description && { description: validatedData.description }),
      updatedAt: new Date(),
    })
    .where(and(
      eq(decksTable.id, validatedData.id),
      eq(decksTable.userId, userId)
    ))
    .returning();

  if (!updatedDeck) {
    throw new Error('Deck not found');
  }

  revalidatePath('/decks');
  revalidatePath(`/decks/${validatedData.id}`);

  return updatedDeck;
}
```

### Pattern: Delete Action

```typescript
'use server';

import { db } from '@/db';
import { decksTable } from '@/db/schema';
import { eq, and } from 'drizzle-orm';
import { auth } from '@clerk/nextjs/server';
import { revalidatePath } from 'next/cache';
import { z } from 'zod';

const deleteDeckSchema = z.object({
  id: z.number().positive(),
});

type DeleteDeckInput = z.infer<typeof deleteDeckSchema>;

export async function deleteDeck(input: DeleteDeckInput) {
  const { userId } = await auth();
  if (!userId) {
    throw new Error('Unauthorized');
  }

  const validatedData = deleteDeckSchema.parse(input);

  const [deletedDeck] = await db
    .delete(decksTable)
    .where(and(
      eq(decksTable.id, validatedData.id),
      eq(decksTable.userId, userId)
    ))
    .returning();

  if (!deletedDeck) {
    throw new Error('Deck not found');
  }

  revalidatePath('/decks');

  return { success: true };
}
```

### Using Server Actions in Client Components

```tsx
'use client';

import { useState } from 'react';
import { Button } from '@/components/ui/button';
import { Input } from '@/components/ui/input';
import { createDeck } from '@/actions/decks';
import type { CreateDeckInput } from '@/lib/validations';

export function CreateDeckForm() {
  const [name, setName] = useState('');
  const [description, setDescription] = useState('');
  const [isLoading, setIsLoading] = useState(false);

  async function handleSubmit(e: React.FormEvent) {
    e.preventDefault();
    setIsLoading(true);

    try {
      const input: CreateDeckInput = {
        name,
        description: description || undefined,
      };

      await createDeck(input);
      
      // Reset form
      setName('');
      setDescription('');
    } catch (error) {
      console.error('Failed to create deck:', error);
      // Handle error (show toast, etc.)
    } finally {
      setIsLoading(false);
    }
  }

  return (
    <form onSubmit={handleSubmit}>
      <Input
        value={name}
        onChange={(e) => setName(e.target.value)}
        placeholder="Deck name"
        disabled={isLoading}
      />
      <Input
        value={description}
        onChange={(e) => setDescription(e.target.value)}
        placeholder="Description"
        disabled={isLoading}
      />
      <Button type="submit" disabled={isLoading}>
        Create Deck
      </Button>
    </form>
  );
}
```

## File Organization

```
src/
├── app/
│   └── decks/
│       └── page.tsx          # Server component (data fetching)
├── components/
│   ├── ui/                   # shadcn/ui components
│   └── deck-card.tsx         # Client component (interactivity)
├── lib/
│   └── validations.ts        # Zod schemas and types
├── actions/
│   └── decks.ts              # Server actions (mutations)
└── db/
    ├── index.ts              # Database client
    └── schema.ts             # Database schema
```

## Validation Best Practices

### 1. Always Parse, Never Validate

Use `.parse()` to both validate and get type-safe data:

```typescript
const validatedData = createDeckSchema.parse(input);
// validatedData is now type-safe
```

### 2. Handle Validation Errors

```typescript
'use server';

import { ZodError } from 'zod';

export async function createDeck(input: CreateDeckInput) {
  try {
    const { userId } = await auth();
    if (!userId) {
      throw new Error('Unauthorized');
    }

    const validatedData = createDeckSchema.parse(input);

    const [newDeck] = await db.insert(decksTable).values({
      userId,
      name: validatedData.name,
      description: validatedData.description || null,
    }).returning();

    revalidatePath('/decks');
    return { success: true, data: newDeck };
  } catch (error) {
    if (error instanceof ZodError) {
      return { success: false, error: error.errors };
    }
    return { success: false, error: 'Failed to create deck' };
  }
}
```

### 3. Reuse Schemas for Types

```typescript
import { z } from 'zod';

export const deckSchema = z.object({
  name: z.string().min(1).max(255),
  description: z.string().max(1000).optional(),
});

// Derive types from schemas
export type DeckInput = z.infer<typeof deckSchema>;
```

## Cache Revalidation

Always revalidate affected paths after mutations:

```typescript
import { revalidatePath } from 'next/cache';

// After creating/updating/deleting
revalidatePath('/decks');               // List page
revalidatePath(`/decks/${deckId}`);     // Detail page
revalidatePath('/', 'layout');          // Entire layout
```

## Security Checklist for Mutations

Before deploying any server action, verify:

- [ ] Action is marked with `'use server'`
- [ ] `auth()` is called and userId is checked
- [ ] Error is thrown if userId is missing
- [ ] Input is validated with Zod schema
- [ ] Input has a proper TypeScript type (NOT FormData)
- [ ] Database queries filter by userId for ownership
- [ ] Affected paths are revalidated
- [ ] Errors are handled appropriately

## Common Patterns Summary

### Data Fetching
```typescript
// Server Component
export default async function Page() {
  const data = await db.select()...;
  return <ClientComponent data={data} />;
}
```

### Data Mutation
```typescript
// actions/resource.ts
'use server';
export async function mutateResource(input: TypedInput) {
  const validated = schema.parse(input);
  await db.insert()...;
  revalidatePath('/path');
}

// Client Component
'use client';
import { mutateResource } from '@/actions/resource';
async function handleAction() {
  await mutateResource({ ... });
}
```

## Resources

- [Next.js Server Components](https://nextjs.org/docs/app/building-your-application/rendering/server-components)
- [Next.js Server Actions](https://nextjs.org/docs/app/building-your-application/data-fetching/server-actions-and-mutations)
- [Zod Documentation](https://zod.dev/)
- [Next.js Revalidation](https://nextjs.org/docs/app/building-your-application/data-fetching/fetching-caching-and-revalidating#revalidating-data)
